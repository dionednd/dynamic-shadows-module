# == Dynamic Shadows Module v0.0.4 == #
#
#	by dionednd
#

# == Changelog == #
#
#	v 0.0.1
#	- implementation
#	v0.0.2
#	- added window parameter to prevent shadow from leaking over.
#	v0.0.3
#	- rewrote half of the code to make the shadows as accurate as possible to real time lighting regardless if in a stage with z axis or not.
#	- added new stage constants
#	- commented code that modified shadow.fade.range and removed intensity code.
#	- added debug mode in training mode. press start on P2 to access move mode 1 / 2. use Debug(Shift+D) to see the light object.
#	v0.0.4
#	- added compatibility for stages. to modify the light position, StageConst(LightOverride) will have to be set to 1.
#	- disabled debug mode by default.

# == Normal States == #

[StateDef 6796790; type: S; ctrl: 0; velset: 0, 0; anim: -1;]
AssertSpecial{flag: invisible;}
AssertSpecial{flag: noshadow;}
NotHitBy{value: SCA}

# == Global States == #

[StateDef -4]

player(2), map(dynamicShadows_debugMode) := 0; # Change to 1 to enable debug mode in training mode.

ignorehitpause if playerno = 1 && NumHelper(6796790) < 1
{
	Helper
	{
		name: "Pseudo-Light Object";
		id: 6796790;
		pos: StageConst(LightPosX), StageConst(LightPosY), StageConst(LightPosZ);
		postype: none;
		facing: 1;
		preserve: 1;
		immortal: 1;
		stateno: 6796790;
		keyctrl: 0;
		supermovetime: -1;
		pausemovetime: -1;
	}
}

ignorehitpause if playerno < 9 && !isHelper && player(1), NumHelper(6796790)
{
	if StageConst(LightOverride) || (player(2), map(dynamicShadows_debugMode) && gamemode = "training")
	{
		let lx = player(1), helper(6796790), pos x;
		let ly = player(1), helper(6796790), pos y;
		let lz = player(1), helper(6796790), pos z + cond(StageConst(LightDisableZOffset) > 0, 0, cond(StageConst(LightZOffset) != 0, StageConst(LightZOffset), -30));
	}
	else
	{	
		let ly_base = -450; #set this to a constant value so the shadows look consistent on all stages
		let h = abs($ly_base);
		let dist = 1.5;
		let lx = (StageVar(shadow.xshear) * $h) * $dist;
		let ly = $ly_base * $dist;
		let lz = -(StageVar(shadow.yscale) * $h) * $dist;
	}

	let px = pos x;
	let py = pos y;
	let pz = pos z;

	let dx = $px - $lx;
	let dy = $py - $ly;
	let dz = $pz - $lz;

	let h = max(1, abs($dy));

	let xs = -($dx / $h);
	let ys = ($dz / $h);

	let ys_clamped = max(-2.0, min($ys, 2.0));

	#let d = ($dx*$dx + $dy*$dy + $dz*$dz)^0.5;
	#let baseI = StageVar(shadow.intensity);
	#let i = max(0, min(256, $baseI - ($d * 0.0000125)));

	ModifyShadow
	{
		offset: 0, 0;
		xshear: $xs;
		yscale: $ys_clamped;
		projection: perspective2;
		focallength: 1331 * abs($ys_clamped);
		window: -9999, cond($ys_clamped<0,-9999,0),9999,cond($ys_clamped<0,0,-9999);
	}
	
	#ModifyStageVar
	#{
	#	shadow.fade.range: $ly, 0;
	#}
}

[StateDef +1]

if playerno = 2 && roundstate = 2 && gamemode = "training"
{
	if InputTime(s) > 0 && !map(___s)
	{
		map(___s) := 1;
		map(movemode) := (map(movemode) + 1) % 3;
	}
	else if InputTime(s) <= 0
	{
		map(___s) := 0;
	}

	if map(movemode)
	{
		ctrlset{value:0}
		if InputTime(L) > 0 && InputTime(R) <= 0
		{
			PosAdd{x: -1 * player(1), helper(6796790), facing;redirectId:player(1), helper(6796790), id}
		}

		if InputTime(R) > 0 && InputTime(L) <= 0
		{
			PosAdd{x: 1 * player(1), helper(6796790), facing;redirectId:player(1), helper(6796790), id}
		}

		if InputTime(U) > 0 && InputTime(D) <= 0
		{
			PosAdd{y: cond(map(movemode) = 1, -1, 0); z: cond(map(movemode) = 2, -1, 0);redirectId:player(1), helper(6796790), id}
		}

		if InputTime(D) > 0 && InputTime(U) <= 0
		{
			PosAdd{y: cond(map(movemode) = 1, 1, 0); z: cond(map(movemode) = 2, 1, 0);redirectId:player(1), helper(6796790), id}
		}
	}
	else if !ctrl & stateno = 0
	{
		ctrlset{value:1}
	}
}
